---
layout: post
title: "Kubernetes Structure"
date: 2021-12-27
categories: Kubernetes
tags: [kubernetes, structure]
---

# **쿠버네티스(Kubernetes)**
## 배경

'어떻게 하면 서버의 상태를 ***쉽게, 안전하게*** 관리할 수 있을까?'에 대한 노력 때문에 생겨났다고 보면 된다.

![쿠버네티스란 무엇인가](https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg)

자체 서버를 운영하던 시절에, 서버를 확장하기 위해서는 서버를 직접 주문하고, 서버를 설치하고, OS를 설치하고 네트워크를 연결하는 등 확장이 어려웠다. 때문에, 가상 머신이 등장했고, 하나의 서버에 여러 대의 가상 서버를 설치할 수 있게 되었다. 게다가, AWS, GCP, Azure와 같은 클라우드 서비스에서 돈만 내면, 즉시 가상화된 서버를 가져다가 쓸 수 있게 되었다.

뒤이어, 모놀리식 아키텍쳐(Monolithic Architecture)에서 마이크로서비스 아키텍쳐(Microservices Architecture)로 점점 발전하여, VM 하나를 통째로 빌려 사용하기에는 낭비가 심한 서비스들이 등장하기 시작할 때 쯤이었다.

운영체제 수준에서 개별 소프트웨어의 독립성을 확보한 **컨테이너**를 통해, 서버의 자원을 효율적으로 사용할 수 있게 되었지만, 그 컨테이너의 개수가 늘어남에 따라, 여러 대의 컨테이너를 관리할 수 있는 툴. 다시 말해, 다수의 컨테이너의 실행을 관리하고 조율하는 컨테이너 오케스트레이션 툴이 필요하였다.

개별 컨테이너를 생성하고 지우는 일은 굉장히 쉬운 일이기 때문에 컨테이너 오케스트레이션 툴의 춘추전국시대가 열리게 되었다. 다양한 툴이 나타났지만, 그중에서도 구글에서 만든 쿠버네티스가 사실상 표준으로 자리잡게 되었다.

이는 쿠버네티스는 단순히 컨테이너의 생성과 삭제를 자동화한 툴이 아니기 때문일 것이다. 쿠버네티스를 운용하면,
- 컨테이너를 어떤 서버에 배포하는 것이 나을지 자동으로 결정할 수 있고,
- 특정 컨테이너의 수요에 따라, 해당 컨테이너의 개수를 조정할 수 있으며,
- 서버를 다운시키지 않아도 컨테이너들을 순차적으로 업데이트할 수 있다. 

그 외에도 다양한 기능을 제공하고 있기에, 쿠버네티스는 컨테이너 기반 애플리케이션의 표준 플랫폼으로 자리잡고 있다.

## 간략한 구조

![Caption](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC2.png?raw=true)

쿠버네티스에는 마스터 노드와 워커 노드가 존재하고, 이러한 노드들의 집합을 클러스터라고 한다. 마스터 노드는 쿠버네티스 클러스터 전체를 컨트롤하는 시스템이고, 워커 노드는 실제 워크로드(workload)에 해당하는 서비스들을 구동하는 머신(machine)이다.





---

# **마스터 노드(Kubernetes Master)**

![Caption](https://github.com/GroomPang/Research/blob/main/%EA%B7%B8%EB%A6%BC1.png?raw=true)

마스터 노드는 여러 컴포넌트(component)를 내부에 두어, 쿠버네티스 클러스터를 관리하고, 모든 컴포넌트는 API 서버를 통해서 통신한다. 이는 관리자만 접속할 수 있고, 보안 설정이 필요하다.

## API 서버

쿠버네티스의 모든 기능들을 REST API로 제공하고, 그에 대한 명령을 처리하는 컴포넌트이다. 쿠버네티스 내부의 모든 컴포넌트들이 서로 호출하기 위해 사용하는 컴포넌트이기도 하다. kubectl 요청뿐만 아니라, 내부 모듈의 요청처리, 권한 체크, 요청 거부, 노드에서 실행 중인 컨테이너 로그를 확인하는 디버거 역할도 가능하다.

클라이언트가 API 서버에 리소스 생성 및 조회의 요청을 보내게 되면, 다음과 같은 과정을 거친다.

1. 요청을 보낸 클라이언트가 인증된 클라이언트인지 확인
2. 인증된 사용자가 현재 보낸 요청을 수행할 수 있는 권한이 있는지 확인
3. (리소스 생성 및 수정, 삭제) 리소스를 기존에 정의된 플러그인을 통해 수정
4. 리소스의 유효성을 확인한 후, etcd에 저장
5. 리소스의 변경 사항을 리소스를 감시하고 있는 모든 클라이언트에게 통보

## etcd

etcd는 쿠버네티스에서 필요한 모든 데이터(e.g. 클러스터의 노드 상태, 특정 파드의 상태)를 저장하는, 분산 key-value 데이터베이스이다. 단순히 값을 저장하고 읽기 뿐만 아니라, watch 기능으로 상태 변경을 체크할 수도 있다. 오직 API 서버와 통신하고, 다른 모듈들도 API 서버를 경유해서 etcd 데이터에 접근한다.

## Scheduler

현재 클러스터에서 자원 할당이 가능한 노드 중에서 가장 우선순위가 높은 노드를 찾아 할당한다. 이 또한 API 서버와 통신하고, 파드의 spec을 변경해 어떤 노드에 스케줄링할 지를 API 서버에게 알리고, API 서버는 해당 노드의 kubelet에 이를 전달하여, 할당한 파드가 실제 컨테이너로 만들지게끔 한다. 우선순위에 영향을 미치는 노드의 조건으로는, affinity와 taint가 있다.

## Controller Manager

**API 서버를 통해, 클러스터 리소스의 변경을 감시하고 변경**하는 작업을 담당한다. 클라이언트가 current 상태를 desired 상태로 만드는 작업을 수행한다. 쿠버네티스에는 기본적으로 제공되는 다양한 Controller가 존재한다.

1. 노드 컨트롤러: 노드를 생성하고 초기화하며 노드에 대해서 응답 여부를 체크하여 비활성화/삭제/수정
2. 레플리케이션 컨트롤러: 설정된 값보다 파드가 많이 생성될 경우 삭제, 또는 오류가 있을 경우 삭제 및 재생성하는 작업 등을 통해 지정된 수의 파드 실행을 보장
3. 엔드포인트 컨트롤러: 서비스와 파드를 연결
4. 서비스 & 계정 컨트롤러 : 새로운 네임스페이스 및 계정에 대한 권한 및 인증을 수행

## DNS

리소스 엔드포인트를 DNS로 매핑하고 관리한다. **파드나 서비스**들은 ip를 배정받지만, **동적으로** **생성**되는 리소스이기 때문에 ip가 변경되면 dns에 위치정보를 저장한다. 새로운 리소스가 생기면 그 리소스에 대한 ip와 dns이름을 등록하고, dns 이름 기반으로 리소스를 접근한다.

---

# **워커 노드(Kubernetes Node)**

![https://galid1.tistory.com/413](https://t1.daumcdn.net/cfile/tistory/99D6D04A5C4D758219)

마스터 노드에 의해 명령을 받고, 실제 워크로드를 생성해서 서비스하는 컴포넌트이다. 컨테이너들이 생성되는 가상머신 또는 물리적인 서버를 의미하고, 각각 서버에 라벨을 붙여서 사용 목적을 정의할 수도 있다. API 서버의 요청은 kubelet을 통해 수행된다.

## kubelet

마스터 노드의 API 서버와 통신하는 컴포넌트이다.

1. 마스터 노드의 API 서버로부터 수행할 명령을 받아서 워커 노드를 수행
2. 워커 노드의 상태를 마스터 노드로 전달

노드에 할당된 파드들의 생명주기를 관리한다. 파드를 생성하고, 파드안의 컨테이너에 이상이 없는지 확인하면서 노드의 상태를 마스터 노드에게 전달한다. API 서버의 요청을 받아서 컨테이너의 로그를 전달하거나, 특정 명령을 대신 수행하기도 한다.

## kube-proxy

노드에서 파드로 연결되는 네트워크를 관리한다. 노드로 오는 트래픽을 적절한 컨테이너로 프록시 하고, 노드와 마스터 간의 네트워크 통신을 관리한다.

kube-proxy는 서비스의 IP 및 포트로 들어온 접속을 서비스의 엔드포인트에 해당하는 파드에 연결하는 역할을 담당한다. proxy라는 이름이 붙은 이유는 초기 쿠버네티스 버전에서 kube-proxy는 userspace에서 동작하던 프록시였기 때문이다. 하지만, 현재는 성능이 더 우수한 iptables 프록시 모드로 수행된다.

---

### References
[Accordion Blog, "클라우드의 시대, 컨테이너 오케스트레이션 툴이 반드시 필요한 이유"](https://accordions.co.kr/it_trend/14778/)

[godpearl, "쿠버네티스 아키텍쳐(2/2) (마스터노드/워커노드)"](https://pearlluck.tistory.com/136)

[Seongpyo Hong, "[Kubernetes 내부 구조 이해하기] 1. 쿠버네티스 클러스터 구성 요소"](https://sphong0417.tistory.com/53)

[kubernetes, "쿠버네티스란 무엇인가?"](https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/)

[kubernetes, "쿠버네티스 컴포넌트"](https://kubernetes.io/ko/docs/concepts/overview/components/)

[커피고래의 노트, "[번역] 쿠버네티스 네트워킹 이해하기#2: Services"](https://coffeewhale.com/k8s/network/2019/05/11/k8s-network-02/)